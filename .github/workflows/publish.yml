name: Publish

on:
  workflow_dispatch:
    inputs:
      package:
        description: 'Package to release'
        required: true
        type: choice
        options:
          - hikkaku
          - create-hikkaku
          - vite-plugin-turbowarp-packager
      release_type:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  id-token: write
  contents: write

jobs:
  publish:
    runs-on: ubuntu-latest
    concurrency:
      group: publish-${{ inputs.package }}
      cancel-in-progress: false
    permissions:
      contents: write
      id-token: write
    env:
      GH_TOKEN: ${{ github.token }}
      PACKAGE_NAME: ${{ inputs.package }}
      INPUT_RELEASE_TYPE: ${{ inputs.release_type }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - uses: actions/setup-node@v4
        with:
          node-version: '24'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Resolve release metadata
        id: metadata
        shell: bash
        run: |
          package="$PACKAGE_NAME"
          release_type="$INPUT_RELEASE_TYPE"

          if ! [[ "$package" =~ ^(hikkaku|create-hikkaku|vite-plugin-turbowarp-packager)$ ]]; then
            echo "Unsupported package: $package"
            exit 1
          fi

          if ! [[ "$release_type" =~ ^(major|minor|patch)$ ]]; then
            echo "Invalid release_type: $release_type"
            echo "Supported values: major, minor, patch"
            exit 1
          fi

          # Derive current version from latest tag for this package
          # If no tags exist, fall back to package.json version
          # Note: Uses git's version sorting which correctly handles semver including prereleases
          latest_tag=$(git tag -l "$package@*" --sort=-version:refname | head -n1)
          
          if [ -n "$latest_tag" ]; then
            # Extract version from tag (format: package@version)
            current_version="${latest_tag#$package@}"
            echo "Found latest tag: $latest_tag (version: $current_version)"
          else
            # No tags exist, use package.json version as starting point
            package_json_path="packages/$package/package.json"
            if [ ! -r "$package_json_path" ]; then
              echo "package.json not found or not readable: $package_json_path"
              exit 1
            fi
            current_version="$(node -e "const fs=require('fs');const pkg=JSON.parse(fs.readFileSync(process.argv[1],'utf8'));process.stdout.write(typeof pkg.version==='string'?pkg.version.trim():'')" "$package_json_path")"
            if [ -z "$current_version" ]; then
              echo "package.json does not contain a valid version field: $package_json_path"
              exit 1
            fi
            echo "No existing tags found, using package.json version: $current_version"
          fi

          if ! [[ "$current_version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)([.-][0-9A-Za-z.-]+)?(\+[0-9A-Za-z.-]+)?$ ]]; then
            echo "Invalid current package version: $current_version"
            exit 1
          fi

          major="${BASH_REMATCH[1]}"
          minor="${BASH_REMATCH[2]}"
          patch="${BASH_REMATCH[3]}"

          case "$release_type" in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          version="$major.$minor.$patch"

          tag="$package@$version"

          if git rev-parse -q --verify "refs/tags/$tag" >/dev/null; then
            echo "Tag already exists: $tag"
            exit 1
          fi

          if gh release view "$tag" >/dev/null 2>&1; then
            echo "Release already exists: $tag"
            exit 1
          fi

          echo "package=$package" >> "$GITHUB_OUTPUT"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "tag=$tag" >> "$GITHUB_OUTPUT"

      - name: Update package version
        run: |
          node -e "const fs=require('fs');const path='packages/${{ steps.metadata.outputs.package }}/package.json';const version='${{ steps.metadata.outputs.version }}';const pkg=JSON.parse(fs.readFileSync(path,'utf8'));pkg.version=version;const hasPrivate=Object.prototype.hasOwnProperty.call(pkg,'private');if(hasPrivate&&(pkg.name==='create-hikkaku'||pkg.name==='vite-plugin-turbowarp-packager')){pkg.private=false;}fs.writeFileSync(path,JSON.stringify(pkg,null,2)+'\n');"

      - name: Build hikkaku
        if: steps.metadata.outputs.package == 'hikkaku'
        run: bun run --filter hikkaku build

      - name: Build create-hikkaku
        if: steps.metadata.outputs.package == 'create-hikkaku'
        run: bun run --filter create-hikkaku build

      - name: Build vite-plugin-turbowarp-packager
        if: steps.metadata.outputs.package == 'vite-plugin-turbowarp-packager'
        run: bun run --filter vite-plugin-turbowarp-packager build

      - name: Build gpts zip
        if: steps.metadata.outputs.package == 'hikkaku'
        run: bun run --filter gpts-zip build

      - name: Publish hikkaku to npm
        if: steps.metadata.outputs.package == 'hikkaku'
        run: npm publish --provenance --access public
        working-directory: packages/hikkaku/dist

      - name: Publish create-hikkaku to npm
        if: steps.metadata.outputs.package == 'create-hikkaku'
        run: npm publish --provenance --access public
        working-directory: packages/create-hikkaku

      - name: Publish vite-plugin-turbowarp-packager to npm
        if: steps.metadata.outputs.package == 'vite-plugin-turbowarp-packager'
        run: npm publish --provenance --access public
        working-directory: packages/vite-plugin-turbowarp-packager

      - name: Create release with generated notes
        run: |
          if [[ '${{ steps.metadata.outputs.package }}' == 'hikkaku' ]]; then
            gh release create '${{ steps.metadata.outputs.tag }}' \
              'packages/gpts-zip/dist.zip#gpts.zip' \
              --generate-notes \
              --target '${{ github.sha }}'
          else
            gh release create '${{ steps.metadata.outputs.tag }}' \
              --generate-notes \
              --target '${{ github.sha }}'
          fi
